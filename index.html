<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arcium & Anonmesh Knowledge Quiz - Improved</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .pixel-font {
      font-family: 'Courier New', monospace;
      text-shadow: 2px 2px 0px rgba(0,0,0,0.3);
    }
    .shadow-glow {
      text-shadow: 0 0 20px rgba(139, 92, 246, 0.5), 0 0 40px rgba(139, 92, 246, 0.3);
    }
    .pixel-button {
      image-rendering: pixelated;
      border: 4px solid rgba(255,255,255,0.3);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .animate-fadeIn {
      animation: fadeIn 0.6s ease-out;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useReducer, useCallback, useMemo } = React;

    // ==================== CONFIGURATION ====================
    
    const GAME_CONFIG = {
      QUESTIONS_PER_QUIZ: 10,
      LEARNING_PAGES: 10,
    };

    const SCORE_TIERS = {
      DECRYPTED: { max: 2, level: '<Decrypted>', icon: 'üîì', color: '#ef4444', desc: 'Vulnerable' },
      PARTIALLY_ENCRYPTED: { max: 5, level: '<Partially Encrypted>', icon: 'üîê', color: '#f59e0b', desc: 'Weak' },
      ENCRYPTED: { max: 8, level: '<Encrypted>', icon: 'üü£', color: '#a78bfa', desc: 'Secure' },
      FULLY_ENCRYPTED: { max: 10, level: '<Fully Encrypted>', icon: '‚òÇÔ∏è', color: '#10b981', desc: 'Maximum Security' },
    };

    const SCREENS = {
      HOME: 'home',
      MODE_SELECT: 'mode-select',
      LEARN_ARCIUM: 'learn-arcium',
      LEARN_ANONMESH: 'learn-anonmesh',
      QUIZ_TOPIC: 'quiz-topic',
      QUIZ_TYPE: 'quiz-type',
      QUIZ: 'quiz',
      RESULTS: 'results',
    };

    const LOGOS = {
      ARCIUM: 'https://i.postimg.cc/PC8sZpR0/20260213-171913-removebg-preview.png',
      ANONMESH: 'https://i.postimg.cc/WD6y6M6D/Coin.png',
    };

    // ==================== LEARNING CONTENT ====================
    
    const ARCIUM_CONTENT = [
      { title: "What is Arcium?", content: "Arcium is a decentralized confidential computing network powered by secure Multi-Party Computation (MPC). It enables scalable, trustless execution of privacy-preserving computations‚Äîfrom confidential voting to federated machine learning‚Äîall while keeping data encrypted even during processing. Unlike traditional computing that exposes data during use, Arcium ensures your sensitive information stays protected at every stage." },
      { title: "The Problem Arcium Solves", content: "Data exists in three states: at rest, in transit, and in use. While encryption for data at rest (storage) and in transit (transmission) is well-established, data in use‚Äîactively being processed‚Äîremains dangerously exposed. Traditional approaches rely on hardware-based Trusted Execution Environments (TEEs), which have critical flaws like vulnerabilities (Spectre, Meltdown) and centralization. Arcium solves this 'data-in-use' problem cryptographically, completing the encryption trinity." },
      { title: "How Multi-Party Computation Works", content: "Arcium uses MPC protocols to split data across multiple nodes called Arx Nodes. These nodes work together to compute results without any single node accessing the complete data. Think of it like a puzzle: each person holds one piece, they can verify the picture is correct without seeing each other's pieces. This eliminates the need for trusted third parties and hardware vulnerabilities." },
      { title: "Key Network Components", content: "The Arcium Network consists of several core elements: Arx Nodes (compute providers that execute MPC), Clusters (groups of nodes working together), MXEs (Multi-Party eXecution Environments for isolated computations), and the ARX token (which powers staking and governance). All orchestration happens on-chain through smart contracts, leveraging Solana's high-performance infrastructure." },
      { title: "ARX Token Economics", content: "ARX is a utility token with dynamic supply that adjusts based on network demand. During low demand, tokens are minted to incentivize nodes to remain in standby. During high demand, ARX is burned (deflated) through a portion of priority fees being swapped and destroyed. This mint-and-burn mechanism ensures the network can bootstrap rapidly while maintaining long-term sustainability." },
      { title: "MPC Protocols - Cerberus & Manticore", content: "Arcium supports two MPC protocols: Cerberus provides the strongest security guarantees using authenticated secret sharing (as long as one honest node exists, computation integrity is guaranteed). Manticore operates faster in 'honest but curious' settings, ideal for machine learning and AI applications. Developers can choose the right protocol for their specific needs‚Äîsecurity vs. speed." },
      { title: "Security & Trust Model", content: "Unlike hardware-based TEEs that can be compromised, Arcium relies purely on cryptographic security through MPC protocols. The network requires NO trust in hardware manufacturers or attestation services. As long as a single honest node exists in a Cluster, the computation's integrity is mathematically guaranteed. This distributed trust model makes Arcium resistant to single points of failure." },
      { title: "Real-World Use Cases", content: "Arcium enables powerful applications: confidential voting (vote without revealing choices), private financial analytics (compute on sensitive data without exposure), federated AI/ML training (train models on encrypted data from multiple parties), secure data collaboration (companies can compute together without sharing raw data), and any computation requiring privacy without trusting a central authority." },
      { title: "Staking & Node Operations", content: "To operate an Arx Node, operators must stake ARX tokens proportional to their computational capacity. This stake acts as collateral‚Äîmisbehavior results in slashing (penalties). Third-party delegators can also stake to nodes, sharing both rewards and slashing risks. Node operators earn through self-delegation rewards and fees from delegators, while the network uses stake-weighted voting to set computation prices." },
      { title: "The Future - Multi-Chain & Scalability", content: "Arcium is blockchain-agnostic by design. While initially deploying on Solana, the network will expand to multiple chains, enabling cross-ecosystem privacy-preserving operations. The modular architecture allows new MPC protocols to be added over time. With parallel execution through MXEs, code splitting, and optimized consensus offloading, Arcium can scale from niche cryptographic operations to enterprise-grade confidential computing." }
    ];

    const ANONMESH_CONTENT = [
      { title: "What is Anonmesh?", content: "Anonmesh is an offline-first, infrastructure-independent network for encrypted communication and crypto payments. It works without internet, WiFi, or cellular networks by creating mesh connections between nearby phones using Bluetooth or LoRa. Born from witnessing infrastructure failures during emergencies, Anonmesh ensures communication and payments work when you need them most‚Äîeven when governments cut access or disasters destroy infrastructure." },
      { title: "Why Infrastructure-Independent Communication Matters", content: "During conflicts, natural disasters, and protests, governments often cut internet access. Traditional payment and communication systems fail completely. Festivals and sporting events overload cell networks. Underground transit has no signal. Remote areas have permanent dead zones. International travel requires expensive data plans. Anonmesh solves all these problems by removing dependency on centralized infrastructure entirely." },
      { title: "How Anonmesh Works", content: "Your phone connects to other nearby phones through Bluetooth or LoRa‚Äîno internet needed. Messages and transactions hop through intermediary devices like passing a note through many people. Each phone becomes a relay point, creating a resilient web of connections. When any node regains internet, transactions are broadcast to Solana blockchain. Everything happens with end-to-end encryption‚Äîintermediaries can't read your data." },
      { title: "Why 'Mesh'?", content: "All phones connect in a mesh network. If you're far from the recipient, your message hops through other phones to reach its destination. Unlike traditional networks with central towers, mesh networks have no single point of failure. Every phone strengthens the network. The more users, the more resilient the system becomes. It's completely peer-to-peer and decentralized." },
      { title: "Why 'Anon'?", content: "No signup. No email. No phone number. No KYC. You only need a Solana wallet. Every time you use the app, you're a random 'shadow node'‚Äîcompletely anonymous. No one knows who you are or can track your activity. Unlike traditional apps that collect data, Anonmesh is built for privacy from the ground up. Your identity is your cryptographic wallet, nothing more." },
      { title: "Powered by Arcium", content: "Anonmesh uses Arcium's confidential computing layer to keep your data encrypted even when it reaches the blockchain. This means double encryption: end-to-end encryption for messages in transit, PLUS on-chain encryption for maximum privacy. Even when transactions are recorded on Solana, the sensitive data remains encrypted using Arcium's Multi-Party Computation protocols." },
      { title: "Real-World Testing & Scale", content: "Anonmesh has been successfully tested across 16 acres of open terrain, proving the mesh network concept works in real conditions. The next challenge is scaling to thousands of simultaneous users‚Äîimagine a packed stadium with 50,000 people or a large protest march. The technology must handle high density, rapid connection changes, and maintain performance under stress." },
      { title: "Emergency Use Cases", content: "Conflict zones: When governments shut down networks to suppress information. Natural disasters: Earthquakes, hurricanes destroy cell towers. Government shutdowns: Protests where authorities cut access. Censorship: Bypass state-level internet blocks. In these critical moments, Anonmesh keeps working when traditional systems fail, enabling coordination, aid distribution, and communication with the outside world." },
      { title: "Everyday Use Cases", content: "Crowded events: Festivals and stadiums where tens of thousands overload networks. Underground transit: Subways and tunnels with no signal. Remote areas: Rural regions with permanent dead zones. International travel: Communicate without expensive roaming or local SIM cards. Privacy-focused use: Anyone wanting to transact or communicate without surveillance or data collection." },
      { title: "How Transactions Work Offline", content: "When you send crypto through Anonmesh while offline: (1) Transaction is signed locally on your device using your Solana wallet. (2) Signed transaction relays through the mesh network, hopping from phone to phone. (3) Transaction is stored and forwarded until ANY node in the network regains internet connection. (4) Once online, transaction is broadcast to Solana blockchain. (5) Confirmation propagates back through the mesh. All without ever needing direct internet access." }
    ];

    // ==================== QUESTIONS (40 each = 80 total) ====================
    // Due to length, I'll include a representative sample and note the rest should be added
    
    const ARCIUM_QUESTIONS = [
      { type: "multiple_choice", question: "What does MPC stand for in Arcium's technology?", options: ["Multi-Party Computation", "Maximum Privacy Control", "Mesh Protocol Communication", "Managed Private Cloud"], correct: "Multi-Party Computation", explanation: "MPC (Multi-Party Computation) is the core cryptographic technology that allows multiple parties to jointly compute a function while keeping their inputs private." },
      { type: "multiple_choice", question: "What is the native token of the Arcium Network?", options: ["ARC", "ARX", "ARCM", "MPC"], correct: "ARX", explanation: "ARX is the utility token of Arcium Network, used for staking, governance, and protocol incentives with a dynamic supply mechanism." },
      { type: "multiple_choice", question: "What are the compute providers in Arcium called?", options: ["Validators", "Arx Nodes", "Miners", "Cluster Nodes"], correct: "Arx Nodes", explanation: "Arx Nodes are individual compute providers that contribute to collective MPC processes and earn rewards for executing computations." },
      { type: "multiple_choice", question: "What does MXE stand for?", options: ["Multi-eXecution Engine", "Multi-Party eXecution Environment", "Maximum eXecution Efficiency", "Mesh eXchange Endpoint"], correct: "Multi-Party eXecution Environment", explanation: "MXEs are isolated virtual environments for secure computation execution, configurable for different privacy and performance needs." },
      { type: "multiple_choice", question: "Which blockchain does Arcium initially deploy on?", options: ["Ethereum", "Solana", "Polkadot", "Cosmos"], correct: "Solana", explanation: "Arcium initially deploys on Solana, leveraging its high-performance infrastructure, though it's designed to be blockchain-agnostic." },
      { type: "multiple_choice", question: "What happens to ARX token supply during high network demand?", options: ["It increases", "It stays the same", "It burns (deflates)", "It splits"], correct: "It burns (deflates)", explanation: "During high demand, a portion of priority fees is swapped to ARX and burned, creating deflationary pressure." },
      { type: "multiple_choice", question: "What is Cerberus in Arcium?", options: ["A wallet", "An MPC protocol", "A token", "A smart contract"], correct: "An MPC protocol", explanation: "Cerberus is Arcium's main MPC protocol backend, providing the strongest security guarantees with authenticated secret sharing." },
      { type: "multiple_choice", question: "What is a Cluster in Arcium?", options: ["A type of token", "A group of Arx Nodes", "A smart contract", "A wallet type"], correct: "A group of Arx Nodes", explanation: "Clusters are groupings of Arx Nodes that collectively execute computations." },
      { type: "multiple_choice", question: "What does ArxOS refer to?", options: ["A mobile operating system", "The execution layer of Arcium", "A programming language", "A blockchain protocol"], correct: "The execution layer of Arcium", explanation: "ArxOS is the distributed execution engine encompassing Arx Nodes, Clusters, and MXEs." },
      { type: "multiple_choice", question: "What is the Target Participation Rate (TPR) at network launch?", options: ["25%", "50%", "75%", "100%"], correct: "50%", explanation: "The TPR is initially set to 50%, representing optimal token supply engagement." },
      { type: "multiple_choice", question: "What is Manticore in Arcium?", options: ["A governance token", "An MPC protocol for ML/AI", "A type of Cluster", "A blockchain"], correct: "An MPC protocol for ML/AI", explanation: "Manticore is Arcium's faster MPC protocol designed for machine learning applications." },
      { type: "multiple_choice", question: "What does CPR stand for in Arcium?", options: ["Computational Processing Rate", "Current Participation Rate", "Cluster Performance Ratio", "Cryptographic Privacy Rating"], correct: "Current Participation Rate", explanation: "CPR is the ratio of staked ARX tokens to total supply, reflecting network utilization." },
      { type: "multiple_choice", question: "What does DKG stand for?", options: ["Dynamic Key Generator", "Distributed Key Generation", "Decentralized Knowledge Graph", "Digital Key Gateway"], correct: "Distributed Key Generation", explanation: "DKG is the protocol where Cluster nodes securely generate and distribute keyshares." },
      { type: "multiple_choice", question: "How many nodes are required for Cerberus protocol security?", options: ["At least 1 honest node", "At least 2 honest nodes", "At least 51% honest nodes", "All nodes must be honest"], correct: "At least 1 honest node", explanation: "As long as one honest node exists in a Cluster, computation integrity is guaranteed." },
      { type: "multiple_choice", question: "What is the smallest unit of computation in Arcium?", options: ["Byte", "Computation Unit (CU)", "Gas Unit", "Arx Unit"], correct: "Computation Unit (CU)", explanation: "The Computation Unit (CU) is the smallest unit of computational work in the Arcium Network." },
      { type: "multiple_choice", question: "What framework is used to write MPC circuits in Arcium?", options: ["Solidity", "Rust", "Arcis", "Python"], correct: "Arcis", explanation: "Arcis is the Rust-based framework for developing privacy-preserving MPC logic." },
      { type: "multiple_choice", question: "What type of data does Arcium protect?", options: ["Data at rest only", "Data in transit only", "Data in use", "All data equally"], correct: "Data in use", explanation: "Arcium specifically solves the 'data-in-use' problem, encrypting data during processing." },
      { type: "multiple_choice", question: "What alternative technology does Arcium NOT rely on?", options: ["Trusted Execution Environments (TEEs)", "Multi-Party Computation", "Cryptographic protocols", "Blockchain consensus"], correct: "Trusted Execution Environments (TEEs)", explanation: "Arcium uses cryptographic MPC instead of vulnerable hardware TEEs." },
      { type: "multiple_choice", question: "What can MXEs be configured as?", options: ["Only single-use", "Only persistent", "Either single-use or persistent", "Only temporary"], correct: "Either single-use or persistent", explanation: "MXEs can be single-use (one computation) or persistent (reusable indefinitely)." },
      { type: "multiple_choice", question: "Which problem does Arcium complete in the 'encryption trinity'?", options: ["Data at rest", "Data in transit", "Data in use", "Data in storage"], correct: "Data in use", explanation: "Arcium completes the encryption trinity by protecting data during processing (in use)." },
      { type: "true_false", question: "Arcium relies on hardware-based Trusted Execution Environments (TEEs) for security.", options: ["True", "False"], correct: "False", explanation: "False. Arcium uses cryptographic MPC protocols instead of vulnerable hardware TEEs." },
      { type: "true_false", question: "At least one honest node in a Cluster is enough to guarantee computation integrity.", options: ["True", "False"], correct: "True", explanation: "True. Arcium's MPC protocol ensures integrity with just one honest node in a Cluster." },
      { type: "true_false", question: "Locked or unvested ARX tokens can be delegated to Arx Nodes.", options: ["True", "False"], correct: "False", explanation: "False. Only liquid tokens can be delegated to ensure accurate participation rate reflection." },
      { type: "true_false", question: "Arcium can only work with one blockchain.", options: ["True", "False"], correct: "False", explanation: "False. Arcium is blockchain-agnostic and will transition to being multi-chain." },
      { type: "true_false", question: "Node operators can vote on the base price for computations.", options: ["True", "False"], correct: "True", explanation: "True. Node operators use stake-weighted voting to set base prices per epoch." },
      { type: "true_false", question: "Arcium uses Fully Homomorphic Encryption (FHE) as its primary technology.", options: ["True", "False"], correct: "False", explanation: "False. Arcium uses MPC, which is much faster than FHE while providing strong privacy." },
      { type: "true_false", question: "MXEs can be either single-use or persistent.", options: ["True", "False"], correct: "True", explanation: "True. MXEs can be configured as single-use or persistent (reusable)." },
      { type: "true_false", question: "ARX token supply increases during high network demand.", options: ["True", "False"], correct: "False", explanation: "False. During high demand, ARX is burned (deflated), not increased." },
      { type: "true_false", question: "Clusters can undergo migration if nodes become unavailable.", options: ["True", "False"], correct: "True", explanation: "True. Clusters can migrate to replace unavailable or untrustworthy nodes." },
      { type: "true_false", question: "Third-party delegators share the same slashing risks as node operators.", options: ["True", "False"], correct: "True", explanation: "True. Both third-party stake and self-delegation can be slashed for misbehavior." },
      { type: "true_false", question: "Arcium's network orchestration is handled entirely off-chain.", options: ["True", "False"], correct: "False", explanation: "False. Network orchestration is handled via on-chain smart contracts." },
      { type: "true_false", question: "The BDOZ protocol is used in Arcium's Cerberus implementation.", options: ["True", "False"], correct: "True", explanation: "True. Cerberus is based on the BDOZ MPC protocol with authentication." },
      { type: "true_false", question: "Stimulative rewards are distributed to all nodes equally.", options: ["True", "False"], correct: "False", explanation: "False. Only a predefined number of top nodes by stake receive stimulative rewards." },
      { type: "true_false", question: "Arcium was inspired by Livepeer's dynamic token economics.", options: ["True", "False"], correct: "True", explanation: "True. Arcium adapted Livepeer's supply mechanism for confidential compute." },
      { type: "true_false", question: "Node operators must provide a minimum self-delegation to operate.", options: ["True", "False"], correct: "True", explanation: "True. Nodes must self-delegate a minimum amount to cover migration costs." },
      { type: "fill_blank", question: "The smallest unit of computation in Arcium is called a ___.", options: ["Computation Unit", "Arx Unit", "Processing Unit", "Gas Unit"], correct: "Computation Unit", explanation: "The Computation Unit (CU) is the smallest unit of computational work." },
      { type: "fill_blank", question: "Arcium's framework for writing MPC circuits is called ___.", options: ["Arcis", "Cerberus", "Manticore", "Solidity"], correct: "Arcis", explanation: "Arcis is the Rust-based framework for developing MPC logic." },
      { type: "fill_blank", question: "The process where nodes generate cryptographic key fragments is called ___.", options: ["DKG", "MPC", "TEE", "KYC"], correct: "DKG", explanation: "DKG (Distributed Key Generation) is the keyshare distribution protocol." },
      { type: "fill_blank", question: "Arcium's main MPC protocol with strongest security is ___.", options: ["Cerberus", "Manticore", "ArxOS", "BDOZ"], correct: "Cerberus", explanation: "Cerberus provides the strongest security guarantees with authenticated sharing." },
      { type: "fill_blank", question: "The execution layer of Arcium is collectively called ___.", options: ["ArxOS", "Solana", "Ethereum", "Blockchain"], correct: "ArxOS", explanation: "ArxOS refers to the distributed execution engine of Arcium." }
    ];

    const ANONMESH_QUESTIONS = [
      { type: "multiple_choice", question: "What wireless technologies does Anonmesh use to connect phones?", options: ["WiFi and 4G", "Bluetooth and LoRa", "5G and NFC", "Satellite and WiFi"], correct: "Bluetooth and LoRa", explanation: "Anonmesh uses Bluetooth and LoRa to create mesh connections without internet." },
      { type: "multiple_choice", question: "What blockchain does Anonmesh use for transactions?", options: ["Ethereum", "Bitcoin", "Solana", "Cardano"], correct: "Solana", explanation: "Anonmesh transactions are broadcast to Solana when nodes regain internet." },
      { type: "multiple_choice", question: "What confidential computing layer powers Anonmesh?", options: ["Secret Network", "Arcium", "Oasis Protocol", "Enigma"], correct: "Arcium", explanation: "Anonmesh uses Arcium's confidential computing for on-chain encryption." },
      { type: "multiple_choice", question: "How large was the terrain where Anonmesh was successfully tested?", options: ["5 acres", "10 acres", "16 acres", "25 acres"], correct: "16 acres", explanation: "Anonmesh has been tested across 16 acres of open terrain." },
      { type: "multiple_choice", question: "What do users need to create to use Anonmesh?", options: ["Email account", "Phone number", "Solana wallet", "Government ID"], correct: "Solana wallet", explanation: "Users only need a Solana wallet‚Äîno KYC required." },
      { type: "multiple_choice", question: "How are messages delivered when you're far from the recipient?", options: ["Through satellites", "Via cellular towers", "They hop through other phones", "Direct internet connection"], correct: "They hop through other phones", explanation: "Messages hop through intermediary phones in the mesh network." },
      { type: "multiple_choice", question: "What type of encryption does Anonmesh use for messages?", options: ["Public encryption", "Basic encryption", "End-to-end encryption", "No encryption"], correct: "End-to-end encryption", explanation: "Anonmesh uses end-to-end encryption for complete privacy." },
      { type: "multiple_choice", question: "When are offline transactions broadcast to the blockchain?", options: ["Immediately", "Never", "When any node gets internet", "After 24 hours"], correct: "When any node gets internet", explanation: "Transactions are broadcast when any node in the network gets internet." },
      { type: "multiple_choice", question: "What are users called in the Anonmesh network?", options: ["Validators", "Shadow nodes", "Miners", "Relays"], correct: "Shadow nodes", explanation: "Every user is a random 'shadow node' for complete anonymity." },
      { type: "multiple_choice", question: "Which scenario is NOT a primary use case for Anonmesh?", options: ["Natural disasters", "High-speed stock trading", "Government internet shutdowns", "Crowded festivals"], correct: "High-speed stock trading", explanation: "Anonmesh is for infrastructure-independent scenarios, not high-frequency trading." },
      { type: "multiple_choice", question: "What inspired the founders to build Anonmesh?", options: ["Academic research", "Witnessing infrastructure failures during emergencies", "Government mandate", "Business opportunity"], correct: "Witnessing infrastructure failures during emergencies", explanation: "Founders saw firsthand how critical and fragile infrastructure is during crises." },
      { type: "multiple_choice", question: "Where does Anonmesh work best?", options: ["Only in cities", "Only in emergencies", "Anywhere without reliable internet", "Only in developed countries"], correct: "Anywhere without reliable internet", explanation: "Anonmesh works in any location lacking reliable internet infrastructure." },
      { type: "multiple_choice", question: "What happens to a transaction signed offline in Anonmesh?", options: ["It's immediately processed", "It's relayed through mesh until a node gets internet", "It's permanently stored offline", "It requires manual upload"], correct: "It's relayed through mesh until a node gets internet", explanation: "Transactions relay through mesh and broadcast when any node connects." },
      { type: "multiple_choice", question: "What is the next scaling challenge for Anonmesh?", options: ["100 simultaneous users", "Thousands of simultaneous users", "10 simultaneous users", "Millions of simultaneous users"], correct: "Thousands of simultaneous users", explanation: "After testing on 16 acres, the goal is scaling to packed stadium levels." },
      { type: "multiple_choice", question: "How does Anonmesh maintain user privacy?", options: ["Centralized encryption", "Shadow node anonymity", "Government verification", "Identity verification"], correct: "Shadow node anonymity", explanation: "Users are random shadow nodes with no traceable identity." },
      { type: "multiple_choice", question: "What type of network infrastructure does Anonmesh create?", options: ["Star network", "Mesh network", "Ring network", "Bus network"], correct: "Mesh network", explanation: "All phones connect in a mesh, creating resilient connections." },
      { type: "multiple_choice", question: "Can intermediary phones read messages they relay?", options: ["Yes, all phones can read messages", "Only some phones can", "No, due to end-to-end encryption", "Only the network operator can"], correct: "No, due to end-to-end encryption", explanation: "End-to-end encryption prevents intermediary phones from reading messages." },
      { type: "multiple_choice", question: "What happens when network infrastructure is cut during protests?", options: ["Anonmesh stops working", "Anonmesh continues working offline", "Requires satellite connection", "Needs government permission"], correct: "Anonmesh continues working offline", explanation: "Anonmesh operates independently of infrastructure during shutdowns." },
      { type: "multiple_choice", question: "What problem does Anonmesh solve in crowded events?", options: ["Ticket sales", "Overloaded cell networks", "Parking issues", "Security screening"], correct: "Overloaded cell networks", explanation: "Festivals and stadiums overload cell networks; Anonmesh bypasses them." },
      { type: "multiple_choice", question: "How does Anonmesh handle international travel?", options: ["Requires roaming plans", "Works without data plans", "Only works in home country", "Requires local SIM card"], correct: "Works without data plans", explanation: "Anonmesh works internationally without requiring data plans." },
      { type: "true_false", question: "Anonmesh requires internet connection to send crypto transactions.", options: ["True", "False"], correct: "False", explanation: "False. Anonmesh works completely offline with transactions relayed through mesh." },
      { type: "true_false", question: "Users must provide KYC information to use Anonmesh.", options: ["True", "False"], correct: "False", explanation: "False. No signup, email, phone number, or KYC required‚Äîonly a Solana wallet." },
      { type: "true_false", question: "Anonmesh was built after founders witnessed infrastructure failures during emergencies.", options: ["True", "False"], correct: "True", explanation: "True. Founders experienced firsthand how fragile infrastructure is during crises." },
      { type: "true_false", question: "Messages in Anonmesh can be read by intermediary phones that relay them.", options: ["True", "False"], correct: "False", explanation: "False. End-to-end encryption prevents intermediaries from reading messages." },
      { type: "true_false", question: "Anonmesh only works in emergency situations.", options: ["True", "False"], correct: "False", explanation: "False. It also works for festivals, transit, rural areas, travel, and privacy use." },
      { type: "true_false", question: "The next challenge for Anonmesh is scaling to thousands of simultaneous users.", options: ["True", "False"], correct: "True", explanation: "True. After 16-acre testing, the goal is packed stadium scale." },
      { type: "true_false", question: "Anonmesh relies on centralized servers to function.", options: ["True", "False"], correct: "False", explanation: "False. Anonmesh is completely decentralized with no central servers." },
      { type: "true_false", question: "Anonmesh works in underground transit systems with no signal.", options: ["True", "False"], correct: "True", explanation: "True. Anonmesh creates mesh connections independent of cell signal." },
      { type: "true_false", question: "Users need to sign up with their email to use Anonmesh.", options: ["True", "False"], correct: "False", explanation: "False. No signup required‚Äîusers are anonymous shadow nodes." },
      { type: "true_false", question: "Anonmesh can work during government internet shutdowns.", options: ["True", "False"], correct: "True", explanation: "True. Anonmesh operates independently of internet infrastructure." },
      { type: "true_false", question: "All phones in Anonmesh connect to a central hub.", options: ["True", "False"], correct: "False", explanation: "False. Phones connect in a peer-to-peer mesh network, not to a hub." },
      { type: "true_false", question: "Anonmesh transactions are signed locally on the device.", options: ["True", "False"], correct: "True", explanation: "True. Transactions are signed locally and relayed through the mesh." },
      { type: "true_false", question: "Anonmesh requires 5G connectivity to function.", options: ["True", "False"], correct: "False", explanation: "False. Anonmesh uses Bluetooth and LoRa, not cellular networks." },
      { type: "true_false", question: "Every Anonmesh user becomes a relay point in the network.", options: ["True", "False"], correct: "True", explanation: "True. Each phone becomes a relay point, creating a resilient web of connections." },
      { type: "true_false", question: "Anonmesh keeps data encrypted even when it reaches the blockchain.", options: ["True", "False"], correct: "True", explanation: "True. Arcium's confidential computing keeps data encrypted on-chain." },
      { type: "fill_blank", question: "In Anonmesh, phones connect through ___ or LoRa without needing internet.", options: ["Bluetooth", "WiFi", "5G", "Satellite"], correct: "Bluetooth", explanation: "Anonmesh uses Bluetooth and LoRa for mesh connections." },
      { type: "fill_blank", question: "Anonmesh keeps crypto working without internet by using a ___ network.", options: ["mesh", "star", "ring", "hub"], correct: "mesh", explanation: "A mesh network connects all phones together for resilient communication." },
      { type: "fill_blank", question: "Every Anonmesh user is a random ___ node for complete anonymity.", options: ["shadow", "validator", "miner", "relay"], correct: "shadow", explanation: "Users are called 'shadow nodes' for complete anonymity." },
      { type: "fill_blank", question: "Anonmesh was tested across ___ acres of open terrain.", options: ["16", "10", "25", "50"], correct: "16", explanation: "Successful testing was conducted across 16 acres." },
      { type: "fill_blank", question: "Anonmesh uses ___ computing layer to keep data encrypted on-chain.", options: ["Arcium", "Ethereum", "Bitcoin", "Polkadot"], correct: "Arcium", explanation: "Anonmesh is powered by Arcium's confidential computing." }
    ];

    // ==================== UTILITIES ====================
    
    const getEncryptionLevel = (score) => {
      if (score <= SCORE_TIERS.DECRYPTED.max) return SCORE_TIERS.DECRYPTED;
      if (score <= SCORE_TIERS.PARTIALLY_ENCRYPTED.max) return SCORE_TIERS.PARTIALLY_ENCRYPTED;
      if (score <= SCORE_TIERS.ENCRYPTED.max) return SCORE_TIERS.ENCRYPTED;
      return SCORE_TIERS.FULLY_ENCRYPTED;
    };

    const getRandomQuestions = (topic, type) => {
      const pool = topic === 'arcium' ? ARCIUM_QUESTIONS : ANONMESH_QUESTIONS;
      const filtered = type === 'mixed' ? pool : pool.filter(q => q.type === type);
      const shuffled = [...filtered].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, GAME_CONFIG.QUESTIONS_PER_QUIZ);
    };

    // ==================== STATE MANAGEMENT ====================
    
    const ACTIONS = {
      SET_SCREEN: 'SET_SCREEN',
      START_QUIZ: 'START_QUIZ',
      ANSWER_QUESTION: 'ANSWER_QUESTION',
      NEXT_QUESTION: 'NEXT_QUESTION',
      RESET_GAME: 'RESET_GAME',
      SET_LEARNING_PAGE: 'SET_LEARNING_PAGE',
      SET_SELECTED_TOPIC: 'SET_SELECTED_TOPIC',
    };

    const initialState = {
      screen: SCREENS.HOME,
      selectedTopic: null,
      selectedType: null,
      currentPage: 0,
      questions: [],
      currentQuestion: 0,
      score: 0,
      answered: false,
      selectedAnswer: null,
      isCorrect: false,
    };

    function quizReducer(state, action) {
      switch (action.type) {
        case ACTIONS.SET_SCREEN:
          return { ...state, screen: action.payload };
        case ACTIONS.START_QUIZ:
          return { ...state, ...action.payload, currentQuestion: 0, score: 0, answered: false, selectedAnswer: null, screen: SCREENS.QUIZ };
        case ACTIONS.ANSWER_QUESTION:
          return { ...state, selectedAnswer: action.payload.answer, answered: true, isCorrect: action.payload.isCorrect, score: action.payload.isCorrect ? state.score + 1 : state.score };
        case ACTIONS.NEXT_QUESTION:
          return state.currentQuestion < state.questions.length - 1 
            ? { ...state, currentQuestion: state.currentQuestion + 1, answered: false, selectedAnswer: null, isCorrect: false }
            : { ...state, screen: SCREENS.RESULTS };
        case ACTIONS.RESET_GAME:
          return initialState;
        case ACTIONS.SET_LEARNING_PAGE:
          return { ...state, currentPage: action.payload };
        case ACTIONS.SET_SELECTED_TOPIC:
          return { ...state, selectedTopic: action.payload };
        default:
          return state;
      }
    }

    // ==================== COMPONENTS ====================
    
    const Button = ({ children, onClick, variant = 'primary', className = '', ...props }) => {
      const variants = {
        primary: 'bg-violet-600 hover:bg-violet-500 focus:ring-violet-300',
        secondary: 'bg-indigo-600 hover:bg-indigo-500 focus:ring-indigo-300',
        success: 'bg-green-600 hover:bg-green-500 focus:ring-green-300',
      };
      return (
        <button
          onClick={onClick}
          className={`px-6 py-3 text-white rounded-lg font-bold transition-all duration-200 focus:outline-none focus:ring-4 ${variants[variant]} ${className}`}
          {...props}
        >
          {children}
        </button>
      );
    };

    const ProgressBar = ({ current, total, color = 'bg-violet-400', bgColor = 'bg-violet-700' }) => (
      <div className={`w-full ${bgColor} rounded-full h-3`} role="progressbar" aria-valuenow={current} aria-valuemin="0" aria-valuemax={total}>
        <div className={`${color} h-3 rounded-full transition-all duration-300`} style={{ width: `${(current / total) * 100}%` }} />
      </div>
    );

    // ==================== MAIN APP ====================
    
    function App() {
      const [state, dispatch] = useReducer(quizReducer, initialState);

      const setScreen = useCallback((screen) => dispatch({ type: ACTIONS.SET_SCREEN, payload: screen }), []);
      const startQuiz = useCallback((topic, type) => {
        const questions = getRandomQuestions(topic, type);
        dispatch({ type: ACTIONS.START_QUIZ, payload: { selectedTopic: topic, selectedType: type, questions } });
      }, []);
      const handleAnswer = useCallback((answer) => {
        if (state.answered) return;
        const currentQ = state.questions[state.currentQuestion];
        const isCorrect = answer === currentQ.correct;
        dispatch({ type: ACTIONS.ANSWER_QUESTION, payload: { answer, isCorrect } });
      }, [state.answered, state.questions, state.currentQuestion]);
      const nextQuestion = useCallback(() => dispatch({ type: ACTIONS.NEXT_QUESTION }), []);
      const resetGame = useCallback(() => dispatch({ type: ACTIONS.RESET_GAME }), []);
      const setLearningPage = useCallback((page) => dispatch({ type: ACTIONS.SET_LEARNING_PAGE, payload: page }), []);
      const setSelectedTopic = useCallback((topic) => dispatch({ type: ACTIONS.SET_SELECTED_TOPIC, payload: topic }), []);

      const currentQ = useMemo(() => state.questions[state.currentQuestion] || null, [state.questions, state.currentQuestion]);

      // HOME SCREEN
      if (state.screen === SCREENS.HOME) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 flex items-center justify-center p-4">
            <div className="max-w-2xl w-full text-center space-y-8 animate-fadeIn">
              <div className="flex justify-center items-center gap-8 mb-8">
                <img src={LOGOS.ARCIUM} alt="Arcium" className="h-24 w-24 object-contain" />
                <img src={LOGOS.ANONMESH} alt="Anonmesh" className="h-24 w-24 object-contain" />
              </div>
              <div className="space-y-4">
                <h1 className="text-6xl font-bold text-white pixel-font tracking-wider shadow-glow">ARCIUM & ANONMESH</h1>
                <h2 className="text-3xl font-bold text-violet-300 pixel-font">KNOWLEDGE QUIZ</h2>
              </div>
              <p className="text-2xl text-violet-200 pixel-font">Let's Learn Together</p>
              <Button onClick={() => setScreen(SCREENS.MODE_SELECT)} className="pixel-button text-2xl px-12 py-6 shadow-xl transform hover:scale-105">START</Button>
              <div className="flex justify-center gap-4 mt-8">
                {[...Array(5)].map((_, i) => (<div key={i} className="w-4 h-4 bg-violet-400 rounded animate-pulse" style={{animationDelay: `${i * 0.1}s`}} />))}
              </div>
            </div>
          </div>
        );
      }

      // MODE SELECTION
      if (state.screen === SCREENS.MODE_SELECT) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-5xl mx-auto">
              <h1 className="text-5xl font-bold text-white text-center mb-4 pixel-font">Choose Your Path</h1>
              <p className="text-xl text-violet-200 text-center mb-12">Select a game mode to begin</p>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
                <button onClick={() => { setScreen(SCREENS.LEARN_ARCIUM); setLearningPage(0); }} className="bg-gradient-to-br from-violet-700 to-purple-700 p-8 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-violet-400">
                  <div className="text-6xl mb-4">üìö</div>
                  <h3 className="text-2xl font-bold text-white mb-2">Learn About</h3>
                  <h4 className="text-3xl font-bold text-violet-200 mb-4">ARCIUM</h4>
                  <p className="text-violet-100">Discover confidential computing and MPC</p>
                </button>
                <button onClick={() => { setScreen(SCREENS.LEARN_ANONMESH); setLearningPage(0); }} className="bg-gradient-to-br from-indigo-700 to-blue-700 p-8 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-indigo-400">
                  <div className="text-6xl mb-4">üìö</div>
                  <h3 className="text-2xl font-bold text-white mb-2">Learn About</h3>
                  <h4 className="text-3xl font-bold text-indigo-200 mb-4">ANONMESH</h4>
                  <p className="text-indigo-100">Explore offline mesh networking</p>
                </button>
                <button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} className="bg-gradient-to-br from-pink-700 to-rose-700 p-8 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-pink-400">
                  <div className="text-6xl mb-4">üß†</div>
                  <h3 className="text-2xl font-bold text-white mb-2">Test Your</h3>
                  <h4 className="text-3xl font-bold text-pink-200 mb-4">KNOWLEDGE</h4>
                  <p className="text-pink-100">Take the quiz and get your score</p>
                </button>
              </div>
              <div className="text-center mt-12">
                <button onClick={() => setScreen(SCREENS.HOME)} className="text-violet-300 hover:text-white text-lg underline">‚Üê Back to Home</button>
              </div>
            </div>
          </div>
        );
      }

      // LEARN ARCIUM
      if (state.screen === SCREENS.LEARN_ARCIUM) {
        const content = ARCIUM_CONTENT[state.currentPage];
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-4xl mx-auto">
              <div className="bg-violet-800/50 backdrop-blur-sm rounded-2xl p-8 shadow-2xl border-4 border-violet-400">
                <div className="flex items-center gap-4 mb-8">
                  <img src={LOGOS.ARCIUM} alt="Arcium" className="h-16 w-16 object-contain" />
                  <h1 className="text-4xl font-bold text-white">Learn About Arcium</h1>
                </div>
                <div className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-2xl font-bold text-violet-200">{content.title}</h2>
                    <span className="text-violet-300">Page {state.currentPage + 1} of {GAME_CONFIG.LEARNING_PAGES}</span>
                  </div>
                  <ProgressBar current={state.currentPage + 1} total={GAME_CONFIG.LEARNING_PAGES} />
                </div>
                <div className="bg-violet-900/50 rounded-xl p-6 mb-8">
                  <p className="text-lg text-white leading-relaxed">{content.content}</p>
                </div>
                <div className="flex justify-between items-center">
                  <Button onClick={() => state.currentPage > 0 && setLearningPage(state.currentPage - 1)} disabled={state.currentPage === 0} className={state.currentPage === 0 ? 'opacity-50 cursor-not-allowed' : ''}>‚Üê Previous</Button>
                  {state.currentPage === GAME_CONFIG.LEARNING_PAGES - 1 ? (
                    <Button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} variant="success">Take Quiz ‚Üí</Button>
                  ) : (
                    <Button onClick={() => setLearningPage(state.currentPage + 1)}>Next ‚Üí</Button>
                  )}
                </div>
                <div className="text-center mt-6">
                  <button onClick={() => setScreen(SCREENS.MODE_SELECT)} className="text-violet-300 hover:text-white underline">‚Üê Back to Menu</button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // LEARN ANONMESH
      if (state.screen === SCREENS.LEARN_ANONMESH) {
        const content = ANONMESH_CONTENT[state.currentPage];
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-4xl mx-auto">
              <div className="bg-indigo-800/50 backdrop-blur-sm rounded-2xl p-8 shadow-2xl border-4 border-indigo-400">
                <div className="flex items-center gap-4 mb-8">
                  <img src={LOGOS.ANONMESH} alt="Anonmesh" className="h-16 w-16 object-contain" />
                  <h1 className="text-4xl font-bold text-white">Learn About Anonmesh</h1>
                </div>
                <div className="mb-6">
                  <div className="flex items-center justify-between mb-4">
                    <h2 className="text-2xl font-bold text-indigo-200">{content.title}</h2>
                    <span className="text-indigo-300">Page {state.currentPage + 1} of {GAME_CONFIG.LEARNING_PAGES}</span>
                  </div>
                  <ProgressBar current={state.currentPage + 1} total={GAME_CONFIG.LEARNING_PAGES} color="bg-indigo-400" bgColor="bg-indigo-700" />
                </div>
                <div className="bg-indigo-900/50 rounded-xl p-6 mb-8">
                  <p className="text-lg text-white leading-relaxed">{content.content}</p>
                </div>
                <div className="flex justify-between items-center">
                  <Button onClick={() => state.currentPage > 0 && setLearningPage(state.currentPage - 1)} disabled={state.currentPage === 0} variant="secondary" className={state.currentPage === 0 ? 'opacity-50 cursor-not-allowed' : ''}>‚Üê Previous</Button>
                  {state.currentPage === GAME_CONFIG.LEARNING_PAGES - 1 ? (
                    <Button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} variant="success">Take Quiz ‚Üí</Button>
                  ) : (
                    <Button onClick={() => setLearningPage(state.currentPage + 1)} variant="secondary">Next ‚Üí</Button>
                  )}
                </div>
                <div className="text-center mt-6">
                  <button onClick={() => setScreen(SCREENS.MODE_SELECT)} className="text-indigo-300 hover:text-white underline">‚Üê Back to Menu</button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // QUIZ TOPIC SELECTION
      if (state.screen === SCREENS.QUIZ_TOPIC) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-5xl mx-auto">
              <h1 className="text-5xl font-bold text-white text-center mb-4 pixel-font">Choose Your Topic</h1>
              <p className="text-xl text-violet-200 text-center mb-12">Which subject do you want to be tested on?</p>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8 max-w-4xl mx-auto">
                <button onClick={() => { setSelectedTopic('arcium'); setScreen(SCREENS.QUIZ_TYPE); }} className="bg-gradient-to-br from-violet-700 to-purple-700 p-12 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-violet-400">
                  <img src={LOGOS.ARCIUM} alt="Arcium" className="h-24 w-24 mx-auto mb-4 object-contain" />
                  <h3 className="text-4xl font-bold text-white mb-2">ARCIUM</h3>
                  <p className="text-violet-100 text-lg">Test your knowledge on confidential computing</p>
                </button>
                <button onClick={() => { setSelectedTopic('anonmesh'); setScreen(SCREENS.QUIZ_TYPE); }} className="bg-gradient-to-br from-indigo-700 to-blue-700 p-12 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-indigo-400">
                  <img src={LOGOS.ANONMESH} alt="Anonmesh" className="h-24 w-24 mx-auto mb-4 object-contain" />
                  <h3 className="text-4xl font-bold text-white mb-2">ANONMESH</h3>
                  <p className="text-indigo-100 text-lg">Test your knowledge on mesh networking</p>
                </button>
              </div>
              <div className="text-center mt-12">
                <button onClick={() => setScreen(SCREENS.MODE_SELECT)} className="text-violet-300 hover:text-white text-lg underline">‚Üê Back to Menu</button>
              </div>
            </div>
          </div>
        );
      }

      // QUIZ TYPE SELECTION
      if (state.screen === SCREENS.QUIZ_TYPE) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-5xl mx-auto">
              <h1 className="text-5xl font-bold text-white text-center mb-4 pixel-font">Choose Question Type</h1>
              <p className="text-xl text-violet-200 text-center mb-12">How do you want to be tested?</p>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                <button onClick={() => startQuiz(state.selectedTopic, 'multiple_choice')} className="bg-gradient-to-br from-violet-700 to-purple-700 p-10 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-violet-400">
                  <div className="text-6xl mb-4">üéØ</div>
                  <h3 className="text-3xl font-bold text-white mb-2">Multiple Choice</h3>
                  <p className="text-violet-100 text-lg">Choose the correct answer from 4 options</p>
                </button>
                <button onClick={() => startQuiz(state.selectedTopic, 'true_false')} className="bg-gradient-to-br from-indigo-700 to-blue-700 p-10 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-indigo-400">
                  <div className="text-6xl mb-4">‚úÖ</div>
                  <h3 className="text-3xl font-bold text-white mb-2">True or False</h3>
                  <p className="text-indigo-100 text-lg">Decide if statements are true or false</p>
                </button>
                <button onClick={() => startQuiz(state.selectedTopic, 'fill_blank')} className="bg-gradient-to-br from-pink-700 to-rose-700 p-10 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-pink-400">
                  <div className="text-6xl mb-4">‚úèÔ∏è</div>
                  <h3 className="text-3xl font-bold text-white mb-2">Fill in the Blank</h3>
                  <p className="text-pink-100 text-lg">Complete the sentence with the right word</p>
                </button>
                <button onClick={() => startQuiz(state.selectedTopic, 'mixed')} className="bg-gradient-to-br from-emerald-700 to-teal-700 p-10 rounded-2xl shadow-2xl hover:scale-105 transition-all duration-300 border-4 border-emerald-400">
                  <div className="text-6xl mb-4">üé≤</div>
                  <h3 className="text-3xl font-bold text-white mb-2">Mixed Mode</h3>
                  <p className="text-emerald-100 text-lg">Random mix of all question types</p>
                </button>
              </div>
              <div className="text-center mt-12">
                <button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} className="text-violet-300 hover:text-white text-lg underline">‚Üê Back to Topics</button>
              </div>
            </div>
          </div>
        );
      }

      // QUIZ SCREEN
      if (state.screen === SCREENS.QUIZ && currentQ) {
        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-3xl mx-auto">
              <div className="bg-violet-800/50 backdrop-blur-sm rounded-2xl p-8 shadow-2xl border-4 border-violet-400">
                <div className="flex items-center justify-between mb-6">
                  <div className="flex items-center gap-3">
                    <img src={state.selectedTopic === 'arcium' ? LOGOS.ARCIUM : LOGOS.ANONMESH} alt={state.selectedTopic} className="h-12 w-12 object-contain" />
                    <span className="text-2xl font-bold text-white capitalize">{state.selectedTopic}</span>
                  </div>
                  <span className="text-xl text-violet-200">Question {state.currentQuestion + 1}/{state.questions.length}</span>
                </div>
                <ProgressBar current={state.currentQuestion + 1} total={state.questions.length} className="mb-8" />
                <div className="bg-violet-900/50 rounded-xl p-6 mb-8">
                  <h2 className="text-2xl text-white font-bold mb-6">{currentQ.question}</h2>
                  <div className="space-y-4">
                    {currentQ.options.map((option, idx) => {
                      let buttonClass = "w-full p-4 rounded-lg text-left text-lg font-semibold transition-all duration-200 border-4 ";
                      if (state.answered) {
                        if (option === currentQ.correct) {
                          buttonClass += "bg-green-600 border-green-400 text-white";
                        } else if (option === state.selectedAnswer) {
                          buttonClass += "bg-red-600 border-red-400 text-white";
                        } else {
                          buttonClass += "bg-gray-600 border-gray-500 text-gray-300";
                        }
                      } else {
                        buttonClass += "bg-violet-700 border-violet-500 hover:bg-violet-600 hover:border-violet-400 text-white cursor-pointer";
                      }
                      return (<button key={idx} onClick={() => handleAnswer(option)} disabled={state.answered} className={buttonClass}>{option}</button>);
                    })}
                  </div>
                </div>
                {state.answered && (
                  <div className={`p-6 rounded-xl mb-6 ${state.isCorrect ? 'bg-green-900/50' : 'bg-red-900/50'}`}>
                    <div className="flex items-center gap-3 mb-3">
                      <span className="text-4xl">{state.isCorrect ? '‚úÖ' : '‚ùå'}</span>
                      <h3 className="text-2xl font-bold text-white">{state.isCorrect ? 'Correct!' : 'Incorrect'}</h3>
                    </div>
                    <p className="text-white text-lg">{currentQ.explanation}</p>
                  </div>
                )}
                <div className="flex justify-between items-center">
                  <div className="text-xl text-violet-200">Score: {state.score}/{state.currentQuestion + (state.answered ? 1 : 0)}</div>
                  {state.answered && (
                    <Button onClick={nextQuestion} className="text-xl px-8 py-4">
                      {state.currentQuestion < state.questions.length - 1 ? 'Next Question ‚Üí' : 'See Results ‚Üí'}
                    </Button>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      }

      // RESULTS SCREEN
      if (state.screen === SCREENS.RESULTS) {
        const { level, icon, color, desc } = getEncryptionLevel(state.score);
        const percentage = Math.round((state.score / state.questions.length) * 100);

        return (
          <div className="min-h-screen bg-gradient-to-br from-violet-900 via-purple-800 to-indigo-900 p-8">
            <div className="max-w-3xl mx-auto text-center">
              <div className="bg-violet-800/50 backdrop-blur-sm rounded-2xl p-12 shadow-2xl border-4 border-violet-400">
                <h1 className="text-5xl font-bold text-white mb-8 pixel-font">Quiz Complete!</h1>
                <div className="mb-8">
                  <div className="text-8xl mb-4">{icon}</div>
                  <h2 className="text-4xl md:text-5xl font-bold mb-4 break-words px-4" style={{color}}>{level}</h2>
                  <p className="text-3xl text-violet-200 mb-2">{desc}</p>
                  <p className="text-6xl font-bold text-white mt-4">{state.score} / {state.questions.length}</p>
                  <p className="text-2xl text-violet-300 mt-2">{percentage}% Correct</p>
                </div>
                {state.score >= 9 && (
                  <div className="bg-green-900/30 border-4 border-green-500 rounded-xl p-6 mb-8">
                    <p className="text-3xl font-bold text-green-300">üéâ Congratulations! üéâ</p>
                    <p className="text-xl text-green-200 mt-2">You're {state.selectedTopic === 'arcium' ? 'an Arcium' : 'an Anonmesh'} expert!</p>
                  </div>
                )}
                <div className="space-y-4">
                  <Button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} className="w-full text-xl px-8 py-4">Play Again</Button>
                  <Button onClick={() => setScreen(SCREENS.QUIZ_TOPIC)} variant="secondary" className="w-full text-xl px-8 py-4">Change Topic</Button>
                  <Button onClick={resetGame} className="w-full text-xl px-8 py-4 bg-purple-600 hover:bg-purple-500 focus:ring-purple-300">Return Home</Button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      return null;
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
